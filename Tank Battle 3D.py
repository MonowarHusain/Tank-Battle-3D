# -*- coding: utf-8 -*-
"""sec15_23241111_22301098_21301132.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_FT5YcPlvKhYCtN3mKnMM9qtBBMiU8xP
"""

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math
import random
import time


WINDOW_WIDTH = 1000
WINDOW_HEIGHT = 800


GRID_LENGTH = 1200
bullet_speed = 20
enemy_speed = 2
max_enemies = 5
fovY = 120

fire_rate = 10  # Fire a bullet every 10 frames
fire_timer = 0  # Timer to track how many frames have passed
# Variable to track total rotation in cheat mode
total_rotation = 0  # Total rotation in degrees

player_pos = [0.0, 0.0, 0.0]
gun_angle = 0.0
bullets = []
enemies = []
lives = 5000
bullets_missed = 0
score = 0
game_over = False
cheat_mode = False
camera_mode = 1
camera_distance = 100
camera_height = 70
tree_positions = []
house_positions = []
explosions = []
powerups = []
shells_fired = 0

turret_angle = 0.0
tank_shake = {"active": False, "start_time": 0, "duration": 0.3, "intensity": 2.0}

def clamp(val, min_val, max_val):
    return max(min_val, min(val, max_val))

def is_collision(new_pos, radius=30):
    """Check if the player tank collides with any house or tree at the new position."""
    for (x, y, _, scale) in tree_positions + house_positions:

        distance = math.sqrt((new_pos[0] - x)**2 + (new_pos[1] - y)**2)
        # If the distance is less than the sum of the radius of the tank and the scale of the obstacle, it's a collision
        if distance < (radius + scale):
            return True  # Collision detected
    return False  # No collision


def spawn_single_enemy():
    max_attempts = 10  # Limit the number of attempts to find a valid spawn position
    for _ in range(max_attempts):
        x = random.uniform(-GRID_LENGTH + 100, GRID_LENGTH - 100)
        y = random.uniform(-GRID_LENGTH + 100, GRID_LENGTH - 100)

        # Check if the new enemy overlaps with any existing enemies
        overlap = False
        for enemy in enemies:
            ex, ey = enemy['pos'][0], enemy['pos'][1]
            distance = math.hypot(ex - x, ey - y)
            if distance < 50:  # 50 is the minimum distance between enemies (adjust if necessary)
                overlap = True
                break

        # If no overlap, spawn the enemy
        if not overlap:
            color_choices = [
                [0.9, 0.1, 0.1],  # Red
                [0.1, 0.1, 0.9],  # Blue
                [0.9, 0.7, 0.1],  # Gold
                [0.7, 0.1, 0.7],  # Purple
                [0.1, 0.7, 0.7],  # Teal
                [0.9, 0.5, 0.1],  # Orange
                [0.5, 0.5, 0.5],  # Gray
                [0.8, 0.2, 0.5],  # Pink
            ]
            color = random.choice(color_choices)
            enemies.append({
                'pos': [x, y, 0.0],
                'has_hit': False,
                'color': color,
                'rotation': random.uniform(0, 360),
                'retreat_timer': 0,  # New: Tracks retreat time
                'retreating': False  # New: Whether enemy is currently retreating
            })
            break

def spawn_enemies():
    global enemies
    enemies = []
    for _ in range(max_enemies):
        spawn_single_enemy()

def spawn_trees(count=40):
    global tree_positions
    tree_positions = []
    for _ in range(count):
        x = random.uniform(-GRID_LENGTH + 100, GRID_LENGTH - 100)
        y = random.uniform(-GRID_LENGTH + 100, GRID_LENGTH - 100)
        scale = random.uniform(0.7, 1.5)
        tree_positions.append((x, y, 0, scale))

def spawn_houses(count=10):
    global house_positions
    house_positions = []
    for _ in range(count):
        x = random.uniform(-GRID_LENGTH + 150, GRID_LENGTH - 150)
        y = random.uniform(-GRID_LENGTH + 150, GRID_LENGTH - 150)
        scale = random.uniform(30, 50)
        house_positions.append((x, y, 0, scale))

def is_enemy_collision(enemy, other_enemy, min_distance=100):
    """Check if two enemies are too close to each other."""
    ex, ey = enemy['pos'][0], enemy['pos'][1]
    other_ex, other_ey = other_enemy['pos'][0], other_enemy['pos'][1]
    distance = math.hypot(ex - other_ex, ey - other_ey)
    return distance < min_distance  # Check if they are too close

def check_enemy_collisions(enemy_id, new_pos, current_enemies):
    """Check if the new position would cause a collision with other enemies."""
    min_distance = 80  # Minimum distance between enemy centers

    for i, other_enemy in enumerate(current_enemies):
        if i == enemy_id:  # Skip checking against itself
            continue

        other_pos = other_enemy['pos']
        distance = math.hypot(new_pos[0] - other_pos[0], new_pos[1] - other_pos[1])

        if distance < min_distance:
            # Collision detected, calculate repulsion vector
            dx = new_pos[0] - other_pos[0]
            dy = new_pos[1] - other_pos[1]

            # Avoid division by zero
            if distance < 0.1:
                dx, dy = random.uniform(-1, 1), random.uniform(-1, 1)
                distance = math.hypot(dx, dy)

            # Use a smaller, more gradual push factor
            push_factor = (min_distance - distance) / min_distance

            # Apply gentler repulsion with dampening
            push_strength = 5.0  # Reduced from 10 to 5
            new_pos[0] += (dx / distance) * push_factor * push_strength
            new_pos[1] += (dy / distance) * push_factor * push_strength

            # Keep within grid boundaries
            new_pos[0] = clamp(new_pos[0], -GRID_LENGTH + 20, GRID_LENGTH - 20)
            new_pos[1] = clamp(new_pos[1], -GRID_LENGTH + 20, GRID_LENGTH - 20)

    return new_pos

def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1, 1, 1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WINDOW_WIDTH, 0, WINDOW_HEIGHT)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_explosion(x, y, z, size, age):
    if age >= 1.0:
        return

    glPushAttrib(GL_ALL_ATTRIB_BITS)
    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

    inner_size = size * (0.5 + age * 0.5)
    middle_size = size * (0.7 + age * 0.8)
    outer_size = size * (1.0 + age * 1.5)
    alpha = max(0, 1.0 - age * 1.5)

    glPushMatrix()
    glTranslatef(x, y, z)

    glColor4f(1.0, 1.0, 0.0, alpha * 0.7)
    glutSolidSphere(outer_size, 16, 16)

    glColor4f(1.0, 0.5, 0.0, alpha * 0.8)
    glutSolidSphere(middle_size, 16, 16)

    glColor4f(1.0, 0.2, 0.0, alpha)
    glutSolidSphere(inner_size, 16, 16)

    if age > 0.3:
        smoke_alpha = min(1.0, (age - 0.3) * 2.0) * 0.6
        glColor4f(0.3, 0.3, 0.3, smoke_alpha)
        for i in range(15):
            angle = random.uniform(0, 2 * math.pi)
            rad = random.uniform(0.8, 1.2) * outer_size * 1.5
            smoke_x = rad * math.cos(angle)
            smoke_y = rad * math.sin(angle)
            smoke_z = random.uniform(-outer_size, outer_size)
            smoke_size = random.uniform(5, 15)

            glPushMatrix()
            glTranslatef(smoke_x, smoke_y, smoke_z)
            glutSolidSphere(smoke_size, 8, 8)
            glPopMatrix()

    glPopMatrix()
    glPopAttrib()

def draw_powerup(x, y, z, powerup_type):
    glPushMatrix()
    glTranslatef(x, y, z + 5)

    if powerup_type == "health":
        glColor3f(1.0, 0.0, 0.0)  # Red
        glutSolidSphere(10, 16, 16)
    elif powerup_type == "rapid_fire":
        glColor3f(0.0, 1.0, 0.0)  # Green
        glutSolidTorus(3, 8, 16, 16)
    elif powerup_type == "shield":
        glColor3f(0.0, 0.0, 1.0)  # Blue
        glutSolidCube(15)

    glPopMatrix()

def draw_tree():
    # Draw trunk (brown cylinder)
    glColor3f(0.55, 0.27, 0.07)
    glPushMatrix()
    quad = gluNewQuadric()
    gluCylinder(quad, 5, 5, 50, 32, 32)
    glPopMatrix()

    # Draw leaves (green cone)
    glColor3f(0.0, 0.6, 0.0)
    glPushMatrix()
    glTranslatef(0.0, 0.0, 50)
    glutSolidCone(15, 60, 32, 32)
    glPopMatrix()

def draw_tree_at(x, y, z, scale=1.0):
    glPushMatrix()
    glTranslatef(x, y, z)
    glScalef(scale, scale, scale)
    draw_tree()
    glPopMatrix()

def draw_cube():
    glColor3f(1.0, 0.85, 0.7)  # Light beige
    glBegin(GL_QUADS)
    # Front
    glVertex3f(-1, 0, 1)
    glVertex3f(1, 0, 1)
    glVertex3f(1, 1, 1)
    glVertex3f(-1, 1, 1)
    # Back
    glVertex3f(-1, 0, -1)
    glVertex3f(1, 0, -1)
    glVertex3f(1, 1, -1)
    glVertex3f(-1, 1, -1)
    # Left
    glVertex3f(-1, 0, -1)
    glVertex3f(-1, 0, 1)
    glVertex3f(-1, 1, 1)
    glVertex3f(-1, 1, -1)
    # Right
    glVertex3f(1, 0, -1)
    glVertex3f(1, 0, 1)
    glVertex3f(1, 1, 1)
    glVertex3f(1, 1, -1)
    # Top
    glVertex3f(-1, 1, -1)
    glVertex3f(-1, 1, 1)
    glVertex3f(1, 1, 1)
    glVertex3f(1, 1, -1)
    # Bottom
    glVertex3f(-1, 0, -1)
    glVertex3f(-1, 0, 1)
    glVertex3f(1, 0, 1)
    glVertex3f(1, 0, -1)
    glEnd()

def draw_roof():
    glColor3f(0.7, 0.13, 0.13)
    glBegin(GL_TRIANGLES)
    glVertex3f(-1, 1, 1)
    glVertex3f(1, 1, 1)
    glVertex3f(0, 1.5, 1)
    glVertex3f(-1, 1, -1)
    glVertex3f(1, 1, -1)
    glVertex3f(0, 1.5, -1)
    glEnd()

    glBegin(GL_QUADS)
    glColor3f(0.5, 0.05, 0.05)
    glVertex3f(-1, 1, -1)
    glVertex3f(-1, 1, 1)
    glVertex3f(0, 1.5, 1)
    glVertex3f(0, 1.5, -1)

    glVertex3f(1, 1, -1)
    glVertex3f(1, 1, 1)
    glVertex3f(0, 1.5, 1)
    glVertex3f(0, 1.5, -1)
    glEnd()

def draw_door(x, y, z, normal):
    glColor3f(0.4, 0.2, 0.1)
    glBegin(GL_QUADS)
    if normal == "z":
        glVertex3f(x - 0.2, y, z)
        glVertex3f(x + 0.2, y, z)
        glVertex3f(x + 0.2, y + 0.6, z)
        glVertex3f(x - 0.2, y + 0.6, z)
    elif normal == "x":
        glVertex3f(x, y, z - 0.2)
        glVertex3f(x, y, z + 0.2)
        glVertex3f(x, y + 0.6, z + 0.2)
        glVertex3f(x, y + 0.6, z - 0.2)
    glEnd()

def draw_window(x, y, z, normal):
    glColor3f(0.2, 0.6, 0.9)
    glBegin(GL_QUADS)
    if normal == "z":
        glVertex3f(x - 0.15, y, z)
        glVertex3f(x + 0.15, y, z)
        glVertex3f(x + 0.15, y + 0.3, z)
        glVertex3f(x - 0.15, y + 0.3, z)
    elif normal == "x":
        glVertex3f(x, y, z - 0.15)
        glVertex3f(x, y, z + 0.15)
        glVertex3f(x, y + 0.3, z + 0.15)
        glVertex3f(x, y + 0.3, z - 0.15)
    glEnd()

def draw_house():
    draw_cube()
    draw_roof()
    draw_door(0, 0, 1.01, "z")
    draw_window(-0.6, 0.3, 1.01, "z")
    draw_window(0.6, 0.3, 1.01, "z")
    draw_window(1.01, 0.3, -0.4, "x")
    draw_window(1.01, 0.3, 0.4, "x")

def draw_house_at(x, y, z, scale=1.0):
    glPushMatrix()
    glTranslatef(x, y, z)
    glScalef(scale, scale, scale)
    glRotatef(90, 1, 0, 0)
    draw_house()
    glPopMatrix()

def draw_grid():
    cx, cy, cz = player_pos[0], player_pos[1], 0

    size = GRID_LENGTH
    glColor3f(0.3, 0.8, 0.3)
    glBegin(GL_QUADS)
    glVertex3f(cx-size, cy-size, 0)
    glVertex3f(cx+size, cy-size, 0)
    glVertex3f(cx+size, cy+size, 0)
    glVertex3f(cx-size, cy+size, 0)
    glEnd()

    wall_height = 800
    glColor3f(0.5, 0.7, 1.0)
    for wall in [
        ((cx-size, cy+size, 0), (cx+size, cy+size, 0), (cx+size, cy+size, wall_height), (cx-size, cy+size, wall_height)),
        ((cx-size, cy-size, 0), (cx+size, cy-size, 0), (cx+size, cy-size, wall_height), (cx-size, cy-size, wall_height)),
        ((cx-size, cy-size, 0), (cx-size, cy+size, 0), (cx-size, cy+size, wall_height), (cx-size, cy-size, wall_height)),
        ((cx+size, cy-size, 0), (cx+size, cy+size, 0), (cx+size, cy+size, wall_height), (cx+size, cy-size, wall_height)),
        ((cx-size, cy-size, wall_height), (cx+size, cy-size, wall_height), (cx+size, cy+size, wall_height), (cx-size, cy+size, wall_height))
    ]:
        glBegin(GL_QUADS)
        for v in wall:
            glVertex3f(*v)
        glEnd()

    for tx, ty, tz, scale in tree_positions:
        draw_tree_at(tx, ty, tz, scale)

    for hx, hy, hz, scale in house_positions:
        draw_house_at(hx, hy, hz, scale)

def draw_tank(tank_color=None, is_enemy=False):
    if tank_color is None:
        main_color = [0.2, 0.3, 0.1]
        turret_color = [0.15, 0.25, 0.1]
    else:
        main_color = tank_color
        turret_color = [max(0, c * 0.85) for c in tank_color]


    if not is_enemy and tank_color is None:

        heat_factor = min(1.0, shells_fired / 10.0)
        barrel_color = [0.2 + 0.8 * heat_factor, 0.2 * (1 - heat_factor), 0.2 * (1 - heat_factor)]
    else:

        barrel_color = [0.2, 0.2, 0.2]

    # Draw tank body
    glColor3f(*main_color)
    glPushMatrix()
    glScalef(42, 25, 12)
    glutSolidCube(1)
    glPopMatrix()

    # Draw turret
    glPushMatrix()
    if not is_enemy:
        # Only apply turret_angle rotation for player tank
        glRotatef(turret_angle, 0, 0, 1)

    # Draw the turret base
    glColor3f(*turret_color)
    glTranslatef(0, 0, 12)
    glScalef(27, 20, 12)
    glutSolidCube(1)
    glPopMatrix()  # End turret transformation

    # Draw the barrel
    glPushMatrix()
    if not is_enemy:
        # Apply turret_angle for player tank
        glRotatef(turret_angle, 0, 0, 1)

    glColor3f(*barrel_color)
    barrel_direction = -30 if is_enemy else 15
    glTranslatef(barrel_direction, 0, 12)
    glRotatef(90, 0, 1, 0)
    quad = gluNewQuadric()
    gluCylinder(quad, 2.5, 2.5, 30, 12, 12)
    glPopMatrix()  # End barrel transformation

    # Draw tracks
    glColor3f(0.1, 0.1, 0.1)

    # Left track
    glPushMatrix()
    glTranslatef(0, 15, 0)
    glScalef(40, 5, 12)
    glutSolidCube(1)
    glPopMatrix()

    # Right track
    glPushMatrix()
    glTranslatef(0, -15, 0)
    glScalef(40, 5, 12)
    glutSolidCube(1)
    glPopMatrix()

    # Draw wheels
    glColor3f(0.3, 0.3, 0.3)
    for x_pos in [-18, -9, 0, 9, 18]:
        # Left wheels
        glPushMatrix()
        glTranslatef(x_pos, 15, 0)
        glutSolidTorus(2.5, 5, 8, 8)
        glPopMatrix()

        # Right wheels
        glPushMatrix()
        glTranslatef(x_pos, -15, 0)
        glutSolidTorus(2.5, 5, 8, 8)
        glPopMatrix()

    # Add stripe for enemy tanks
    if tank_color is not None:
        stripe_color = [1-c for c in tank_color]
        glColor3f(*stripe_color)
        glPushMatrix()
        glTranslatef(0, 0, 6)
        glRotatef(90, 0, 1, 0)
        glScalef(3, 26, 1)
        glutSolidCube(1)
        glPopMatrix()
def specialKeyListener(key, x, y):
    global camera_distance, camera_height
    if key == GLUT_KEY_LEFT:
        camera_distance -= 10
    elif key == GLUT_KEY_RIGHT:
        camera_distance += 10
    elif key == GLUT_KEY_UP:
        camera_height += 10
    elif key == GLUT_KEY_DOWN:
        camera_height -= 10
    camera_distance = max(50, min(camera_distance, 1000))
    camera_height = max(50, min(camera_height, 500))

def mouseListener(button, state, x, y):
    global bullets, game_over, tank_shake, shells_fired
    if game_over:
        return
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
        combined_angle= (gun_angle+turret_angle)%360
        angle_rad = math.radians(combined_angle)
        bx = player_pos[0] + 45 * math.cos(angle_rad)
        by = player_pos[1] + 45 * math.sin(angle_rad)
        bullets.append({'pos': [bx, by, 0], 'angle': combined_angle})
        tank_shake["active"] = True
        tank_shake["start_time"] = time.time()
        shells_fired += 1
    if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
        global camera_mode
        camera_mode = 3 if camera_mode == 1 else 1

def setupCamera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(fovY, WINDOW_WIDTH / WINDOW_HEIGHT, 0.1, 1500)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    shake_offset_x = 0
    shake_offset_y = 0
    shake_offset_z = 0

    if tank_shake["active"]:
        elapsed = time.time() - tank_shake["start_time"]
        if elapsed < tank_shake["duration"]:
            intensity = tank_shake["intensity"] * (1 - elapsed / tank_shake["duration"])
            shake_offset_x = random.uniform(-intensity, intensity)
            shake_offset_y = random.uniform(-intensity, intensity)
            shake_offset_z = random.uniform(-intensity/2, intensity/2)
        else:
            tank_shake["active"] = False

    if camera_mode == 1:
        combined_angle=(gun_angle+turret_angle)%360
        eye_x = player_pos[0] + 40 * math.cos(math.radians(combined_angle))+shake_offset_x
        eye_y = player_pos[1] + 40 * math.sin(math.radians(combined_angle))+shake_offset_y
        eye_z = 40+shake_offset_z
        center_x = player_pos[0] + 100 * math.cos(math.radians(combined_angle))
        center_y = player_pos[1] + 100 * math.sin(math.radians(combined_angle))
        center_z = 40
        gluLookAt(eye_x, eye_y, eye_z, center_x, center_y, center_z, 0, 0, 1)
    else:
        angle_rad = math.radians(gun_angle + 180)
        eye_x = player_pos[0] + camera_distance * math.cos(angle_rad)+shake_offset_x
        eye_y = player_pos[1] + camera_distance * math.sin(angle_rad)+shake_offset_y
        eye_z = camera_height+shake_offset_z
        center_x = player_pos[0]
        center_y = player_pos[1]
        center_z = 30
        gluLookAt(eye_x, eye_y, eye_z, center_x, center_y, center_z, 0, 0, 1)

def idle():
    global bullets, enemies, bullets_missed, lives, game_over, gun_angle, score, explosions, cheat_mode, fire_timer, total_rotation, shells_fired
    if game_over:
        glutPostRedisplay()
        return


    if shells_fired > 0:
        shells_fired -= 0.01
        shells_fired = max(0, shells_fired)


    if cheat_mode:
        rotation_speed = 1
        gun_angle = (gun_angle + rotation_speed) % 360


        total_rotation += rotation_speed


        fire_timer += 1
        if fire_timer >= fire_rate:
            fire_timer = 0
            angle_rad = math.radians(gun_angle)
            bx = player_pos[0] + 45 * math.cos(angle_rad)
            by = player_pos[1] + 45 * math.sin(angle_rad)
            bullets.append({'pos': [bx, by, 0], 'angle': gun_angle})
            shells_fired += 1


    new_bullets = []
    for bullet in bullets:
        bullet['pos'][0] += bullet_speed * math.cos(math.radians(bullet['angle']))
        bullet['pos'][1] += bullet_speed * math.sin(math.radians(bullet['angle']))


        hit_enemy = False
        for enemy in enemies:
            ex, ey = enemy['pos'][0], enemy['pos'][1]
            if math.hypot(ex - bullet['pos'][0], ey - bullet['pos'][1]) < 30:

                explosions.append({
                    'pos': [ex, ey, 0],
                    'size': 40,
                    'start_time': time.time()
                })
                score += 1

                enemies.remove(enemy)

                spawn_single_enemy()
                hit_enemy = True
                break

        if not hit_enemy:

            if -GRID_LENGTH < bullet['pos'][0] < GRID_LENGTH and -GRID_LENGTH < bullet['pos'][1] < GRID_LENGTH:
                new_bullets.append(bullet)
            else:
                bullets_missed += 1

                if bullets_missed >= 10:
                    game_over = True

    bullets = new_bullets


    new_enemies = []
    for enemy_id, enemy in enumerate(enemies):
        ex, ey = enemy['pos'][0], enemy['pos'][1]
        dx = player_pos[0] - ex
        dy = player_pos[1] - ey
        dist = math.hypot(dx, dy)

        enemy['rotation'] = (180 + math.degrees(math.atan2(dy, dx)))

        if dist < 50:
            if not enemy['has_hit']:
                lives -= 1
                enemy['has_hit'] = True
                enemy['retreating'] = True
                enemy['retreat_timer'] = time.time()

            if lives <= 0:
                game_over = True
        else:
            enemy['has_hit'] = False


        if enemy['retreating']:

            if time.time() - enemy['retreat_timer'] < 0.4:

                new_x = ex - enemy_speed * 0.5 * dx / dist
                new_y = ey - enemy_speed * 0.5 * dy / dist
            else:

                enemy['retreating'] = False
                new_x = ex + enemy_speed * dx / dist
                new_y = ey + enemy_speed * dy / dist
        else:

            new_x = ex + enemy_speed * dx / dist
            new_y = ey + enemy_speed * dy / dist

        new_x = clamp(new_x, -GRID_LENGTH + 20, GRID_LENGTH - 20)
        new_y = clamp(new_y, -GRID_LENGTH + 20, GRID_LENGTH - 20)


        new_pos = [new_x, new_y, 0]
        adjusted_pos = check_enemy_collisions(enemy_id, new_pos, enemies)
        enemy['pos'][0] = adjusted_pos[0]
        enemy['pos'][1] = adjusted_pos[1]

        new_enemies.append(enemy)

    enemies[:] = new_enemies

    current_time = time.time()
    new_explosions = []
    for explosion in explosions:
        age = current_time - explosion['start_time']
        if age < 1.5:
            new_explosions.append(explosion)
    explosions = new_explosions

    glutPostRedisplay()

def keyboardListener(key, x, y):
    global player_pos, gun_angle, cheat_mode, camera_mode, lives, bullets_missed, game_over, score, shells_fired, turret_angle

    if game_over and key != b'r':
        return


    new_x, new_y = player_pos[0], player_pos[1]

    if key == b'w':
        new_x += 10 * math.cos(math.radians(gun_angle))
        new_y += 10 * math.sin(math.radians(gun_angle))
    elif key == b's':  # Move backward
        new_x -= 10 * math.cos(math.radians(gun_angle))
        new_y -= 10 * math.sin(math.radians(gun_angle))
    elif key == b'a':  # Rotate left
        gun_angle += 5
    elif key == b'd':  # Rotate right
        gun_angle -= 5
    elif key == b'c':  # Toggle cheat mode
        cheat_mode = not cheat_mode
    elif key == b'v':  # Toggle camera mode
        camera_mode = 3 if camera_mode == 1 else 1
    elif key== b'q':
        turret_angle =turret_angle+5
    elif key ==b'e':
        turret_angle=turret_angle-5
    elif key == b'r':  # Restart the game
        lives = 5000
        bullets_missed = 0
        score = 0
        game_over = False
        shells_fired = 0  # Reset shells fired counter
        spawn_enemies()
        bullets.clear()


    if not is_collision([new_x, new_y]):
        player_pos[0] = clamp(new_x, -GRID_LENGTH + 20, GRID_LENGTH - 20)
        player_pos[1] = clamp(new_y, -GRID_LENGTH + 20, GRID_LENGTH - 20)

def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT)
    setupCamera()
    draw_grid()

    glPushMatrix()
    glTranslatef(player_pos[0], player_pos[1], 12)
    glRotatef(gun_angle, 0, 0, 1)
    if camera_mode == 3 or game_over:
        draw_tank()
    glPopMatrix()

    for e in enemies:
        glPushMatrix()
        glTranslatef(e['pos'][0], e['pos'][1], 12)
        glRotatef(e['rotation'], 0, 0, 1)
        draw_tank(e['color'], is_enemy=True)
        glPopMatrix()

    current_time = time.time()
    for explosion in explosions:
        age = current_time - explosion['start_time']
        draw_explosion(explosion['pos'][0], explosion['pos'][1], explosion['pos'][2],
                      explosion['size'], age)

    for b in bullets:
        glPushMatrix()
        glTranslatef(b['pos'][0], b['pos'][1], 24)
        glColor3f(1, 0.7, 0)
        glutSolidSphere(7, 12, 12)
        glPopMatrix()

    draw_text(10, 770, f"Tank Health: {lives}")
    draw_text(10, 740, f"Score: {score}")
    draw_text(10, 710, f"Shells Missed: {bullets_missed}")
    draw_text(10, 680, f"Camera Mode: {'First-Person' if camera_mode == 1 else 'Third-Person'}")
    if game_over:
        draw_text(400, 400, "GAME OVER! Press R to Restart", GLUT_BITMAP_TIMES_ROMAN_24)
    glutSwapBuffers()

def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT)
    glutInitWindowPosition(0, 0)
    glutCreateWindow(b"Tank Battle 3D")
    glEnable(GL_DEPTH_TEST)
    spawn_enemies()
    spawn_trees()
    spawn_houses()
    glutDisplayFunc(showScreen)
    glutKeyboardFunc(keyboardListener)
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)
    glutMainLoop()

if __name__ == "__main__":
    main()